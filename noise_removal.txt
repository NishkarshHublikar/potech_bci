class synapse {
  public:
    float eeg_filter(float input)
    {
      float output = input;
      {
        static float z1, z2; // filter section state
        float x = output - -0.42615248*z1 - 0.08290189*z2;
        output = 0.03701685*x + 0.07403370*z1 + 0.03701685*z2;
        z2 = z1;
        z1 = x;
      }
      {
        static float z1, z2; // filter section state
        float x = output - -0.56685322*z1 - 0.48368568*z2;
        output = 1.00000000*x + 2.00000000*z1 + 1.00000000*z2;
        z2 = z1;
        z1 = x;
      }
      {
        static float z1, z2; // filter section state
        float x = output - -1.97658291*z1 - 0.97674412*z2;
        output = 1.00000000*x + -2.00000000*z1 + 1.00000000*z2;
        z2 = z1;
        z1 = x;
      }
      {
        static float z1, z2; // filter section state
        float x = output - -1.99039779*z1 - 0.99055580*z2;
        output = 1.00000000*x + -2.00000000*z1 + 1.00000000*z2;
        z2 = z1;
        z1 = x;
      }
      return output;
    }

    // Band-Pass Butterworth IIR digital filter to remove AC noise
    float remove_AC_noise(uint8_t type, float input)
    {
      float output = input; // Default output initialization

      switch (type)
      {
        case 50:
          {
            static float z1, z2; 
            float x = output - -0.58621390*z1 - 0.95447062*z2;
            output = 0.93642755*x + -0.57892689*z1 + 0.93642755*z2;
            z2 = z1;
            z1 = x;
          }
          {
            static float z1, z2;
            float x = output - -0.62207340*z1 - 0.95474810*z2;
            output = 1.00000000*x + -0.61822923*z1 + 1.00000000*z2;
            z2 = z1;
            z1 = x;
          }
          {
            static float z1, z2;
            float x = output - -0.56822557*z1 - 0.98081132*z2;
            output = 1.00000000*x + -0.61822923*z1 + 1.00000000*z2;
            z2 = z1;
            z1 = x;
          }
          {
            static float z1, z2;
            float x = output - -0.65580392*z1 - 0.98109606*z2;
            output = 1.00000000*x + -0.61822923*z1 + 1.00000000*z2;
            z2 = z1;
            z1 = x;
          }
          return output;

        case 60:
          {
            static float z1, z2;
            float x = output - -0.10398666*z1 - 0.95458249*z2;
            output = 0.93642755*x + -0.11763470*z1 + 0.93642755*z2;
            z2 = z1;
            z1 = x;
          }
          {
            static float z1, z2;
            float x = output - -0.14153054*z1 - 0.95463621*z2;
            output = 1.00000000*x + -0.12562071*z1 + 1.00000000*z2;
            z2 = z1;
            z1 = x;
          }
          {
            static float z1, z2;
            float x = output - -0.07845058*z1 - 0.98092611*z2;
            output = 1.00000000*x + -0.12562071*z1 + 1.00000000*z2;
            z2 = z1;
            z1 = x;
          }
          {
            static float z1, z2;
            float x = output - -0.17026534*z1 - 0.98098125*z2;
            output = 1.00000000*x + -0.12562071*z1 + 1.00000000*z2;
            z2 = z1;
            z1 = x;
          }
          return output;

        default:
          return input; // If an invalid type is given, return input unchanged
      }
    }

    // Apply EEG filters (low-pass and notch)
    float apply_EEG_filters(float input_signal){
      float eeg_filter_out = eeg_filter(input_signal);
      float band_stop_out = remove_AC_noise(50, eeg_filter_out);
      return band_stop_out;
    }
};

// Pin definition
const int sensorPin = A0; // Analog input pin for EEG sensor
unsigned long previousMillis = 0;
unsigned long interval = 100; // Sampling interval in milliseconds

synapse exg_synapse; // Create an instance of the synapse class

void setup() {
  Serial.begin(9600); // Start serial communication
}

void loop() { 
  unsigned long currentMillis = millis();
  
  if (currentMillis - previousMillis >= interval) {
    previousMillis = currentMillis;
    
    float sensorValue = analogRead(sensorPin); // Read sensor data
    float filters_out = exg_synapse.apply_EEG_filters(sensorValue); // Apply filtering

    Serial.println(filters_out); // Print filtered EEG signal
  }
}
